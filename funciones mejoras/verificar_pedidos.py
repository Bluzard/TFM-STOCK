# -*- coding: utf-8 -*-
"""verificar_pedidos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ks38McYDfULD6m5gV5ScKVnTQZiQc8nW
"""



"""Para implementar esta mejora, vamos a crear una funci칩n llamada verificar_pedidos que verificar치 si los pedidos confirmados a futuro provocan que el stock previsto caiga por debajo del stock de seguridad en alg칰n momento durante el periodo de planificaci칩n. Si esto ocurre, se a침adir치 el art칤culo a la lista de productos que deben planificarse."""

import pandas as pd
from datetime import datetime, timedelta

def verificar_pedidos(productos, archivo_pedidos, fecha_dataset, dias_planificacion):
    """
    Verifica si los pedidos confirmados a futuro provocan que el stock previsto
    caiga por debajo del stock de seguridad en alg칰n momento durante el periodo de planificaci칩n.

    :param productos: Lista de productos con demanda media y stock inicial calculados.
    :param fecha_dataset: Fecha del dataset (datetime).
    :param dias_planificacion: N칰mero de d칤as de planificaci칩n.
    :return: Lista de productos que deben planificarse adicionalmente debido a pedidos.
    """
    try:
        # Generar el nombre del archivo de pedidos
        fecha_dataset_str = fecha_dataset.strftime('%d-%m-%y')
        archivo_pedidos = f'/content/Pedidos pendientes {fecha_dataset_str}.csv'

        # Verificar si el archivo existe
        if not os.path.exists(archivo_pedidos):
            logger.warning(f"No se encontr칩 el archivo de pedidos: {archivo_pedidos}")
            return []

        # Leer el archivo de pedidos
        df_pedidos = pd.read_csv(archivo_pedidos, sep=';', encoding='latin1')

        # Convertir las columnas de fechas a datetime
        fechas_pedidos = [col for col in df_pedidos.columns if col.startswith('09') or col.startswith('10') or col.startswith('11') or col.startswith('12') or col.startswith('13') or col.startswith('14') or col.startswith('15') or col.startswith('16') or col.startswith('17') or col.startswith('18') or col.startswith('19') or col.startswith('20') or col.startswith('21') or col.startswith('22') or col.startswith('23') or col.startswith('24') or col.startswith('25') or col.startswith('26') or col.startswith('27') or col.startswith('28') or col.startswith('29') or col.startswith('30') or col.startswith('31')]
        df_pedidos[fechas_pedidos] = df_pedidos[fechas_pedidos].apply(pd.to_numeric, errors='coerce').fillna(0)

        # Convertir fechas a datetime
        df_pedidos['COD_ART'] = df_pedidos['COD_ART'].astype(str)

        # Lista de productos que deben planificarse adicionalmente
        productos_a_planificar = []

        # Recorrer cada producto
        for producto in productos:
            if producto.demanda_media <= 0:
                continue  # No se considera si no hay demanda media

            # Obtener los pedidos para este producto
            pedidos_producto = df_pedidos[df_pedidos['COD_ART'] == producto.cod_art]
            if pedidos_producto.empty:
                continue  # No hay pedidos para este producto

            # Inicializar el stock previsto
            stock_previsto = producto.stock_inicial
            stock_seguridad = producto.demanda_media * 3

            # Recorrer d칤a a d칤a
            for i in range(dias_planificacion):
                fecha_actual = fecha_dataset + timedelta(days=i)
                fecha_str = fecha_actual.strftime('%d/%m/%Y')

                # Restar la demanda media
                stock_previsto -= producto.demanda_media

                # Sumar la OF si la fecha es igual o superior a la del dataset
                if hasattr(producto, 'primera_of') and producto.primera_of != '(en blanco)':
                    of_date = datetime.strptime(producto.primera_of, '%d/%m/%Y')
                    if of_date <= fecha_actual:
                        stock_previsto += producto.of

                # Restar los pedidos del d칤a
                if fecha_str in df_pedidos.columns:
                    pedido_dia = pedidos_producto[fecha_str].values[0]
                    if pd.notna(pedido_dia):
                        stock_previsto -= abs(pedido_dia)  # Los pedidos son negativos en el archivo

                # Verificar si el stock previsto es menor que el stock de seguridad
                if stock_previsto < stock_seguridad:
                    logger.warning(f"El d칤a {fecha_str}, el stock de seguridad ha sido sobrepasado para el producto {producto.cod_art}.")

                    # Calcular la cantidad a fabricar
                    dias_faltantes = dias_planificacion - i
                    cantidad_a_fabricar = producto.demanda_media * min(dias_faltantes + 7, dias_planificacion) + abs(pedido_dia)

                    # A침adir el producto a la lista de productos a planificar
                    producto.cajas_a_producir = cantidad_a_fabricar
                    productos_a_planificar.append(producto)
                    break  # Solo necesitamos detectar la primera vez que se sobrepasa el stock de seguridad

        logger.info(f"Se han identificado {len(productos_a_planificar)} productos adicionales para planificar debido a pedidos.")
        return productos_a_planificar

    except Exception as e:
        logger.error(f"Error verificando pedidos: {str(e)}")
        return []

"""Explicaci칩n de la Funci칩n
Lectura del Archivo de Pedidos:

Se lee el archivo CSV de pedidos pendientes.

Las columnas de fechas se convierten a valores num칠ricos (los pedidos son negativos en el archivo).

Recorrido de Productos:

Para cada producto, se inicializa el stock previsto con el stock inicial.

Se calcula el stock de seguridad como demanda_media * 3.

Simulaci칩n D칤a a D칤a:

Se simula el stock previsto restando la demanda media y sumando las OF si corresponde.

Se restan los pedidos del d칤a actual si existen.

Verificaci칩n de Stock de Seguridad:

Si el stock previsto cae por debajo del stock de seguridad, se registra una advertencia y se calcula la cantidad a fabricar.

La cantidad a fabricar asegura cubrir los pedidos desproporcionados y mantener el stock durante al menos 7 d칤as despu칠s del periodo de planificaci칩n.

Productos a Planificar:

Los productos que requieren planificaci칩n adicional se a침aden a la lista productos_a_planificar.

Integraci칩n en el Flujo Principal
La funci칩n verificar_pedidos se integra en el flujo principal despu칠s de calcular la demanda media y antes de aplicar el m칠todo Simplex. Aqu칤 est치 el fragmento relevante:
"""

def main():
    try:
        logger.info("Iniciando planificaci칩n de producci칩n...")

        # (C칩digo existente para leer par치metros y dataset)

        # 1. Leer dataset y calcular f칩rmulas
        productos = leer_dataset('/content/Dataset 09-01-25.csv')
        if not productos:
            raise ValueError("Error al leer el dataset")

        productos_validos, horas_disponibles = calcular_formulas(
            productos=productos,
            fecha_inicio=fecha_planificacion,
            fecha_dataset=fecha_dataset,
            dias_planificacion=dias_planificacion,
            dias_no_habiles=dias_no_habiles,
            horas_mantenimiento=horas_mantenimiento
        )

        if not productos_validos:
            raise ValueError("Error en los c치lculos")

        # 2. Verificar pedidos pendientes
        productos_a_planificar_adicionales = verificar_pedidos(
            productos=productos,
            fecha_dataset=fecha_dataset_dt,
            dias_planificacion=dias_planificacion
        )

        # Combinar productos v치lidos con los adicionales
        productos_a_planificar = productos_validos + productos_a_planificar_adicionales

        # 3. Aplicar Simplex
        productos_optimizados = aplicar_simplex(
            productos_validos=productos_a_planificar,
            horas_disponibles=horas_disponibles,
            dias_planificacion=dias_planificacion,
            dias_cobertura_base=dias_cobertura_base
        )

        if not productos_optimizados:
            raise ValueError("Error en la optimizaci칩n")

        # (Resto del c칩digo para ordenar y exportar resultados)

    except Exception as e:
        logger.error(f"Error en ejecuci칩n: {str(e)}")
        return None

"""Resultado
Productos Adicionales:

Los productos que requieren planificaci칩n adicional debido a pedidos desproporcionados se a침aden a la lista de productos a planificar.

Estos productos se incluyen en la optimizaci칩n con el m칠todo Simplex.

Advertencias:

Si el stock previsto cae por debajo del stock de seguridad, se registra una advertencia en el log.

Ejemplo de Salida
Si el producto 400121 tiene un pedido desproporcionado el d칤a 10/01/2025, el log mostrar치:

WARNING: El d칤a 10/01/2025, el stock de seguridad ha sido sobrepasado para el producto 400121.

Y el producto se a침adir치 a la lista de productos a planificar.

Con esta mejora, el sistema ahora tiene en cuenta los pedidos confirmados a futuro, evitando roturas de stock y asegurando una planificaci칩n m치s robusta. 춰Espero que esta implementaci칩n sea 칰til! 游땕
"""