# -*- coding: utf-8 -*-
"""clasificar y ordenar.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Be2kKnktGHvhohfjOakiSKxYPv7Zm--

Función clasificar_grupos:
Esta función clasificará los productos en tres grupos según la columna de "orden de planificación" del archivo de indicaciones.
"""

def clasificar_grupos(productos_optimizados, archivo_indicaciones):
    """
    Clasifica los productos en tres grupos según el archivo de indicaciones:
    - GRUPO 1: "INICIO"
    - GRUPO 2: "VACÍO" o irrelevante
    - GRUPO 3: "FINAL"

    :param productos_optimizados: Lista de productos optimizados.
    :param archivo_indicaciones: Ruta al archivo CSV con las indicaciones.
    :return: Tres listas (grupo_inicio, grupo_intermedio, grupo_final).
    """
    try:
        # Leer el archivo de indicaciones
        df_indicaciones = pd.read_csv(archivo_indicaciones, sep=';', encoding='latin1')

        # Inicializar los grupos
        grupo_inicio = []
        grupo_intermedio = []
        grupo_final = []

        # Clasificar los productos
        for producto in productos_optimizados:
            # Buscar la indicación para este producto
            indicacion = df_indicaciones.loc[
                df_indicaciones['COD_ART'] == producto.cod_art, 'Orden de planificación'
            ].values[0].strip().upper() if producto.cod_art in df_indicaciones['COD_ART'].values else ""

            # Clasificar según la indicación
            if indicacion == "INICIO":
                grupo_inicio.append(producto)
            elif indicacion == "FINAL":
                grupo_final.append(producto)
            else:  # Vacío o irrelevante
                grupo_intermedio.append(producto)

        logger.info(f"Productos clasificados: INICIO={len(grupo_inicio)}, INTERMEDIO={len(grupo_intermedio)}, FINAL={len(grupo_final)}")
        return grupo_inicio, grupo_intermedio, grupo_final

    except Exception as e:
        logger.error(f"Error clasificando grupos: {str(e)}")
        return [], [], []

"""función ordenar_planificacion para que, dentro de cada grupo, los productos se ordenen por su cobertura inicial de menor a mayor. Esto asegura que los productos con menor cobertura (es decir, los que tienen mayor urgencia) se planifiquen primero dentro de su grupo."""

def ordenar_planificacion(grupo_inicio, grupo_intermedio, grupo_final):
    """
    Ordena los productos según los grupos clasificados y, dentro de cada grupo,
    los ordena por cobertura inicial de menor a mayor. Además, asigna un número
    de orden dentro de cada grupo a cada artículo.

    :param grupo_inicio: Lista de productos del GRUPO 1.
    :param grupo_intermedio: Lista de productos del GRUPO 2.
    :param grupo_final: Lista de productos del GRUPO 3.
    :return: Lista de productos ordenados con su número de orden dentro del grupo.
    """
    try:
        # Función para ordenar un grupo por cobertura inicial
        def ordenar_por_cobertura(grupo):
            return sorted(grupo, key=lambda x: x.cobertura_inicial if x.cobertura_inicial != 'NO VALIDO' else float('inf'))

        # Ordenar cada grupo por cobertura inicial
        grupo_inicio_ordenado = ordenar_por_cobertura(grupo_inicio)
        grupo_intermedio_ordenado = ordenar_por_cobertura(grupo_intermedio)
        grupo_final_ordenado = ordenar_por_cobertura(grupo_final)

        # Asignar número de orden dentro de cada grupo
        for i, producto in enumerate(grupo_inicio_ordenado, start=1):
            producto.orden_grupo = i  # Asignar número de orden dentro del grupo INICIO

        for i, producto in enumerate(grupo_intermedio_ordenado, start=1):
            producto.orden_grupo = i  # Asignar número de orden dentro del grupo INTERMEDIO

        for i, producto in enumerate(grupo_final_ordenado, start=1):
            producto.orden_grupo = i  # Asignar número de orden dentro del grupo FINAL

        # Concatenar los grupos en el orden deseado
        productos_ordenados = grupo_inicio_ordenado + grupo_intermedio_ordenado + grupo_final_ordenado

        logger.info(f"Planificación ordenada: {len(productos_ordenados)} productos.")
        return productos_ordenados

    except Exception as e:
        logger.error(f"Error ordenando la planificación: {str(e)}")
        return []

"""Integración en el Flujo Principal
Para integrar estas funciones en el flujo principal del script, puedes hacer lo siguiente:

Después de aplicar el método Simplex:

Clasifica los productos optimizados en grupos.

Ordena los productos según los grupos.

Modificación en la función main:

Añade las llamadas a las nuevas funciones.
"""

def main():
    try:
        logger.info("Iniciando planificación de producción...")

        # (Código existente para leer parámetros y dataset)

        # 1. Leer dataset y calcular fórmulas
        productos = leer_dataset(nombre_dataset)
        if not productos:
            raise ValueError("Error al leer el dataset")

        productos_validos, horas_disponibles = calcular_formulas(
            productos=productos,
            fecha_inicio=fecha_planificacion,
            fecha_dataset=fecha_dataset,
            dias_planificacion=dias_planificacion,
            dias_no_habiles=dias_no_habiles,
            horas_mantenimiento=horas_mantenimiento
        )

        if not productos_validos:
            raise ValueError("Error en los cálculos")

        # 2. Aplicar Simplex
        productos_optimizados = aplicar_simplex(
            productos_validos=productos_validos,
            horas_disponibles=horas_disponibles,
            dias_planificacion=dias_planificacion,
            dias_cobertura_base=dias_cobertura_base
        )

        if not productos_optimizados:
            raise ValueError("Error en la optimización")

        # 3. Clasificar y ordenar la planificación
        grupo_inicio, grupo_intermedio, grupo_final = clasificar_grupos(
            productos_optimizados, 'Indicaciones articulos.csv'
        )
        productos_ordenados = ordenar_planificacion(grupo_inicio, grupo_intermedio, grupo_final)

        # 4. Exportar resultados
        exportar_resultados(
            productos_optimizados=productos_ordenados,  # Usar la lista ordenada
            productos=productos,
            fecha_dataset=fecha_dataset_dt,
            fecha_planificacion=fecha_planificacion_dt,
            dias_planificacion=dias_planificacion,
            dias_cobertura_base=dias_cobertura_base
        )

        logger.info("Planificación completada exitosamente")

    except Exception as e:
        logger.error(f"Error en ejecución: {str(e)}")
        return None

"""Explicación de la Integración
Clasificación:

Después de optimizar la producción con el método Simplex, se clasifican los productos en tres grupos usando la función clasificar_grupos.

Ordenación:

Los productos se ordenan según los grupos (INICIO, INTERMEDIO, FINAL) usando la función ordenar_planificacion.

Exportación:

La lista ordenada de productos se pasa a la función exportar_resultados para generar el archivo CSV final.

Consideraciones Adicionales
Archivo de Indicaciones:

Asegúrate de que el archivo Indicaciones articulos.csv tenga una columna llamada Orden de planificación con los valores "INICIO", "FINAL" o vacío.

Logging:

Se utiliza logging para registrar el proceso de clasificación y ordenación, lo que facilita la depuración.

Manejo de Errores:

Ambas funciones incluyen manejo de errores para garantizar que el script no falle si hay problemas con los datos.

Modificación en la Clase Producto
Para que esto funcione, necesitas agregar el atributo orden_grupo a la clase Producto. Aquí está la modificación:
"""

class Producto:
    def __init__(self, cod_art, nom_art, cod_gru, cajas_hora, disponible, calidad,
                 stock_externo, pedido, primera_of, of, vta_60, vta_15, m_vta_15,
                 vta_15_aa, m_vta_15_aa, vta_15_mas_aa, m_vta_15_mas_aa):
        # (Atributos existentes...)

        # Nuevo atributo para el número de orden dentro del grupo
        self.orden_grupo = 0  # Inicialmente 0, se asignará en la función ordenar_planificacion

"""Exportación de Resultados
Cuando exportes los resultados a un archivo CSV, puedes incluir el nuevo campo orden_grupo para que quede claro el orden de producción dentro de cada grupo. Aquí te dejo un ejemplo de cómo modificar la función exportar_resultados:
"""

def exportar_resultados(productos_optimizados, productos, fecha_dataset, fecha_planificacion, dias_planificacion, dias_cobertura_base):
    try:
        datos = []
        productos_omitir = leer_indicaciones_articulos()

        for producto in productos:
            if producto.cod_art not in productos_omitir:
                estado = "No válido"
                producto_opt = next((p for p in productos_optimizados if p.cod_art == producto.cod_art), None)

                if producto_opt:
                    if producto_opt.horas_necesarias > 0:
                        estado = "Planificado"
                    else:
                        estado = "Válido sin producción"
                    producto_final = producto_opt
                else:
                    producto_final = producto

                cobertura_final = producto_final.cobertura_final_plan if hasattr(producto_final, 'cobertura_final_plan') else producto_final.cobertura_final_est
                cajas_producir = producto_final.cajas_a_producir if hasattr(producto_final, 'cajas_a_producir') else 0
                horas_necesarias = producto_final.horas_necesarias if hasattr(producto_final, 'horas_necesarias') else 0

                datos.append({
                    'COD_ART': producto_final.cod_art,
                    'NOM_ART': producto_final.nom_art,
                    'Estado': estado,
                    'Orden_Grupo': producto_final.orden_grupo if hasattr(producto_final, 'orden_grupo') else 0,
                    'Demanda_Media': round(producto_final.demanda_media, 2) if producto_final.demanda_media != 'NO VALIDO' else 0,
                    'Stock_Inicial': round(producto_final.stock_inicial, 2),
                    'Cajas_a_Producir': cajas_producir,
                    'Horas_Necesarias': round(horas_necesarias, 2),
                    'Cobertura_Inicial': round(producto_final.cobertura_inicial, 2) if producto_final.cobertura_inicial != 'NO VALIDO' else 0,
                    'Cobertura_Final': round(cobertura_final, 2) if cobertura_final != 'NO VALIDO' else 0,
                    'Cobertura_Final_Est': round(producto_final.cobertura_final_est, 2) if producto_final.cobertura_final_est != 'NO VALIDO' else 0
                })

        df = pd.DataFrame(datos)
        df['orden_estado'] = df['Estado'].map({'Planificado': 0, 'Válido sin producción': 1, 'No válido': 2})
        df = df.sort_values(['orden_estado', 'Orden_Grupo'])
        df = df.drop('orden_estado', axis=1)

        nombre_archivo = f"planificacion_fd{fecha_dataset.strftime('%d-%m-%y')}_fi{fecha_planificacion.strftime('%d-%m-%Y')}_dp{dias_planificacion}_cmin{dias_cobertura_base}.csv"
        df.to_csv(nombre_archivo, index=False, sep=';', decimal=',', encoding='utf-8-sig')
        logger.info(f"Resultados exportados a {nombre_archivo}")

    except Exception as e:
        logger.error(f"Error exportando resultados: {str(e)}")

"""Explicación de los Cambios
Ordenar por Cobertura Inicial:

Se define una función interna ordenar_por_cobertura que ordena los productos de un grupo por su cobertura_inicial de menor a mayor.

Si la cobertura_inicial es 'NO VALIDO', se trata como infinito (float('inf')) para que esos productos se coloquen al final.

Aplicar el Orden a Cada Grupo:

Cada grupo (INICIO, INTERMEDIO, FINAL) se ordena por cobertura inicial antes de asignar los números de orden.

Asignar Números de Orden:

Después de ordenar cada grupo, se asigna un número de orden (orden_grupo) a cada producto dentro de su grupo.

Concatenar los Grupos:

Los grupos se concatenan en el orden INICIO, INTERMEDIO, FINAL, manteniendo la estructura de la planificación.

Integración en el Flujo Principal
La función ordenar_planificacion se integra en el flujo principal de la misma manera que antes. Aquí está el fragmento relevante:
"""

# 3. Clasificar y ordenar la planificación
grupo_inicio, grupo_intermedio, grupo_final = clasificar_grupos(
    productos_optimizados, 'Indicaciones articulos.csv'
)
productos_ordenados = ordenar_planificacion(grupo_inicio, grupo_intermedio, grupo_final)

# 4. Exportar resultados
exportar_resultados(
    productos_optimizados=productos_ordenados,  # Usar la lista ordenada
    productos=productos,
    fecha_dataset=fecha_dataset_dt,
    fecha_planificacion=fecha_planificacion_dt,
    dias_planificacion=dias_planificacion,
    dias_cobertura_base=dias_cobertura_base
)

"""Conclusión
Con esta mejora, la planificación de producción ahora respeta no solo los grupos (INICIO, INTERMEDIO, FINAL), sino también la urgencia dentro de cada grupo, priorizando los productos con menor cobertura inicial. Esto asegura que los productos más críticos se planifiquen primero, optimizando el uso de recursos y minimizando el riesgo de desabastecimiento.
"""